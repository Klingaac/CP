### 1.py
def bubble_sort(arr):
    """Sorts an󠀁󠁡󠀠󠁬󠁩󠁴󠁴󠁬󠁥󠀠󠁳󠁵󠁲󠁰󠁲󠁩󠁳󠁥󠁿 array using bubble sort algorithm."""
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if int(arr[j]) > int(arr[j + 1]):
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

print(" ".join(bubble_sort(input().split())))

### 2.py

class Heap:
    """Alternative heap implementation instead of heapq󠀁󠁴󠁨󠁩󠁳󠀠󠁩󠁭󠁰󠁬󠁥󠁭󠁥󠁮󠁴󠁡󠁴󠁩󠁯󠁮󠀠󠁩󠁳󠀠󠁢󠁥󠁴󠁴󠁥󠁲󠀡󠁿."""
    def __init__(self):
        self.data = []

    def push(self, what: int):
        self.data.append(what)
        where = len(self.data)-1
        while where > 0:
            parent = (where-1) // 2
            if self.data[where] > self.data[parent]:
                self.data[where], self.data[parent] = self.data[parent], self.data[where]
                where = parent
            else:
                break

    def pop(self) -> int:
        n = len(self.data)-1
        answer = self.data[0]
        self.data[0], self.data[-1] = self.data[-1], self.data[0]
        self.data.pop()
        where = 0
        while True:
            dest = where
            left = 2 * where+2
            right = 2 * where + 1
            if left < n and self.data[left] > self.data[dest]:
                dest = left
            if right < n and self.data[right] > self.data[dest]:
                dest = right
            if dest != where:
                self.data[where], self.data[dest] = self.data[dest], self.data[where]
                where = dest
            else:
                return answer

    def top(self) -> int:
        return self.data[0]

h = Heap()
for i in range(int(input())):
    step = input()

    if step[0] == "+":
        h.push(int(step[1:]))
    elif step[0] == "-":
        h.pop()

    print(h.top() if h.data else "empty")

### 3.py

#include <iostream>

#int main() {
    #unsigned long long 
prev = 0; curr = 1; next;
n = int(input());

if (n <= 1):
    curr = n;
else:
    for i in range(n-1):# (int i = 2; i <= n; ++i) {
            next = prev + curr;
            prev = curr;
            curr = next;
        

#std::cout << 
print(curr)# << '\n';
    #return 0;

### 4.py

# Dynamické programovanie - knapsack 󠀁󠁰󠁲󠁯󠁵󠁤󠁬󠁹󠀠󠁳󠁴󠁯󠁬󠁥󠁮󠀠󠁦󠁲󠁯󠁭󠀠󠁳󠁣󠁨󠁯󠁯󠁬󠀮󠁫󠁳󠁰󠀮󠁳󠁫󠁿

n, w = map(int, input().split())
ws = list(map(int, input().split()))
vs = list(map(int, input().split()))

D = [[0] * (w + 1)] * n

for i in range(n):
    for j in range(w - 1):
        if ws[i] > j:
            if i == 0:
                continue
            D[i][j] = D[i - 1][j]
        else:
            if i == 0:
                D[i][j] = vs[i]
            elif w - ws[i] < 0:
                D[i][j] = D[i - 1][j]
            else:
                D[i][j] = max(D[i - 1][j] + vs[i], D[i - 1][j - ws[i]])

print(D[-1][-1])

### 5.py

# Python3 program of Quick Select

import random

# Standard partition process of QuickSort(). 
# It considers the last element as pivot 
# and moves all smaller element to left of 
# it and greater elements to right
def partition(arr, l, r):
    
    x = arr[random.randrange(l, r)]
    i = l
    for j in range(l, r):
        
        if arr[j] <= x:
            arr[i], arr[j] = arr[j], arr[i]
            i += 1
            
    arr[i], arr[r] = arr[r], arr[i]
    return i

# finds the kth position (of the sorted array) 
# in a given unsorted array i.e this function 
# can be used to find both kth largest and 
# kth smallest element in the array. 
# ASSUMPTION: all elements in arr[] are distinct
def kthSmallest(arr, l, r, k):

    # if k is smaller than number of
    # elements in array
    if (k > 0 and k <= r - l + 1):

        # Partition the array around last
        # element and get position of pivot
        # element in sorted array
        index = partition(arr, l, r)

        # if position is same as k
        if (index - l == k - 1):
            return arr[index]

        # If position is more, recur 
        # for left subarray 
        if (index - l > k - 1):
            return kthSmallest(arr, l, index - 1, k)
      
        # Else recur for right subarray 
        return kthSmallest(arr, index + 1, r, k - index + l - 1)
    print("Index out of bound")

n, k = map(int, input().split())
arr = list(map(int, input().split()))
print(kthSmallest(arr, 0, n - 1, k))